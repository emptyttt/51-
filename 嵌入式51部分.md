

# 嵌入式51部分

[TOC]

STC89C52，51单片机

## 原理图

 [普中-2&普中-3&普中-4开发板原理图.pdf](51单片机\普中-2&普中-3&普中-4开发板原理图.pdf) 

## 进制转换

<img src="https://i-blog.csdnimg.cn/blog_migrate/a7b3597d4712d9d0fa6502805b822f23.png" alt="img" style="zoom:70%;" />

0x表示16进制

## 软件延时函数

```c
void Delay1ms(unsigned int xms)	//@11.0592MHz
{
	unsigned char data i, j;

	//_nop_();//需要添加头文件也可以直接注释掉
  while(xms){
    i = 2;
		j = 199;
		do
		{
			while (--j);
		} while (--i);
    
    xms--;
  }
}

```

这里do-while循环有两层，外层循环执行一次，内层循环执行j次，而外层循环执行i次

当j==0时内层循环结束，i==0时外层循环结束，总的算下来的时间差不多为1ms

关于在嵌入式系统中j在do-while循环中有没有初始化的问题还暂时不清楚

## 按键消抖

```c
void main()
{
    while (1)//一定要加一个无限循环
    {
		if(P3_1==0)//如果 P3_1 引脚为低电平，执行下面代码
		{
			Delay(20);//消除按键抖动
			while(P3_1==0);//等待 P3_1 引脚恢复为高电平（即按键松开）。这段代码确保在按键松开之前不会继续执行下面代码。
      //可以尝试在按键的时候时间放长点，会发现到此时灯不亮或者没有熄灭
			Delay(20);//再次延迟，进一步消除按键抖动
			
			P2_0=~P2_0;//将 P2_0 引脚的状态取反。如果 P2_0 原来是高电平，则变为低电平；如果是低电平，则变为高电平。
		
		}
```

## 独立按键控制LED显示二进制

```c
void main()
{
	unsigned char LEDNum=0;//0000 0000
		
	while(1)
	{
		if(P3_1==0)
		{
			Delay(20);
			while(P3_1==0);
			Delay(20);
			//1111 1111 0xFF
			//P2++;//0000 0000
			LEDNum++;
			P2=~LEDNum;
		
		}
	}
```

**更详细的按键和LED状态变化示例**

![截屏2024-07-10 13.01.11](/Users/tanliuna/Library/Application Support/typora-user-images/截屏2024-07-10 13.01.11.png)

## 独立按键控制LED移位

```C
void main()
{
	//P2=~0x01;//from P2_0
	unsigned char LEDNum=0;
		
	while(1)
	{
		if(P3_1==0)
		{
			Delay(20);
			while(P3_1==0);
			Delay(20);
			
			LEDNum++;
			if(LEDNum>=8)//左移8位后会溢出
			{
				LEDNum=0;
			}
			P2=~(0x01<<LEDNum);//按位左移
		}
		if(P3_0==0)
		{
			Delay(20);
			while(P3_0==0);
			Delay(20);
			
			if(LEDNum==0)
				LEDNum=7;
			else
				LEDNum--;
			P2=~(0x01<<LEDNum);
			
			
		}
	}	
}
```

**超过8位的左移运算结果无效**：

如果 LEDNum 达到8或更大的值，0x01 << LEDNum 结果会超出8位范围，导致意外的结果。例如：

0x01 << 8 在某些编译器上可能等于 0x00，因为左移超过了字节的长度（8位）。

这样会导致所有的LED灯都熄灭，因为 P2 = ~0x00 = 0xFF（所有位都是1，高电平）。

## 静态数码管

数码管**不可以在同一个时刻显示多个数字**

**COM共阴极，COM-AN共阳极，GRN共阳极**

### 138译码器

位选、段选

3-8线：将3种输入状态转化为8种输出状态
$$
2^3=8
$$
ABC为输入端，Y0-Y7为输出端，G1、G2AB为使能端

给CBA数据101➡️Y5有效0

### 双向数据缓冲器

OE低电平有效

DIR

### 二进制转化为十进制

从最低位（最右）算起，位上的数字乘以本位的权重，权重就是2的第几位的位数减一的次方。

比如第2位就是2的（2-1次）方，就是2；第8位就是2的（8-1）次方是128。把所有度的值加起来。

2（1-1）代表2的0次方，就是1；其他类推

比如二进制1101，知换算成十进制就是：
$$
1*2^3+1*2^2+0*2^1+1*2^0=13
$$
**CC2电容pF nF uF mF F电源滤波**	

C数组：相同类型的数据

```C
int x[3];
int x[]={1,2,3};
```



**段码读的是数据高位**

**数码管段码**

| 显示数字 | 段码 |
| :------: | :--: |
|    0     | 0x3F |
|    1     | 0x06 |
|    2     | 0x5B |
|    3     | 0x4F |
|    4     | 0x66 |
|    5     | 0x6D |
|    6     | 0x7D |
|    7     | 0x07 |
|    8     | 0x7F |
|    9     | 0x6F |

![4397c76a7983cff5f254caa631f19d0](C:\Users\Anna\Documents\WeChat Files\wxid_lqrkt1mxadlp31\FileStorage\Temp\4397c76a7983cff5f254caa631f19d0.jpg)

```c
unsigned char NixieTable[]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F};
void Nixie(unsigned char Location,Number)
{
	switch(Location)
	{
		case 1:P2_4=1;P2_3=1;P2_2=1;break;
		case 2:P2_4=1;P2_3=1;P2_2=0;break;
		case 3:P2_4=1;P2_3=0;P2_2=1;break;
		case 4:P2_4=1;P2_3=0;P2_2=0;break;
		case 5:P2_4=0;P2_3=1;P2_2=1;break;
		case 6:P2_4=0;P2_3=1;P2_2=0;break;
		case 7:P2_4=0;P2_3=0;P2_2=1;break;
		case 8:P2_4=0;P2_3=0;P2_2=0;break;
	}
	P0=NixieTable[Number];
}
```

## 动态数码管

消影

位选-段选-位选-段选

如果不加延时函数，在位选的时候就会上一段选就会继续

数码管的驱动方式： 

1.单片机直接扫描：硬件设备简单，但会耗费大量单片机CPU时间

2.专用驱动芯片：内部自带显存、扫描电路，单片机只需要告诉它显示什么即可

TM1640

74HC595内部一位寄存器，三根数据线，两根电源线，控制8个数码管。

 Nixie 函数来显示数字，但是没有足够的延迟来分别显示每个数字。每次调用 Nixie 函数时，都会立即刷新显示，这使得所有数字看起来像是同时显示。

```C
#include <REGX52.H>
unsigned char NixieTable[]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F};
void Delay(unsigned int xms)	//@11.0592MHz
{
	unsigned char data i, j;
	
	while(xms--)
	{
		i = 2;
	j = 199;
	do
	{
		while (--j);
	} while (--i);
	}
	
}

void Nixie(unsigned char Location,Number)
{
	switch(Location)
	{
		case 1:P2_4=1;P2_3=1;P2_2=1;break;
		case 2:P2_4=1;P2_3=1;P2_2=0;break;
		case 3:P2_4=1;P2_3=0;P2_2=1;break;
		case 4:P2_4=1;P2_3=0;P2_2=0;break;
		case 5:P2_4=0;P2_3=1;P2_2=1;break;
		case 6:P2_4=0;P2_3=1;P2_2=0;break;
		case 7:P2_4=0;P2_3=0;P2_2=1;break;
		case 8:P2_4=0;P2_3=0;P2_2=0;break;
	}
	P0=NixieTable[Number];
	Delay(1);
	P0=0x00;
}
void main()
{
	while(1)
	{
		Nixie(1,1);
//		Delay(200);
		Nixie(2,2);
//		Delay(200);
		Nixie(3,3);
//		Delay(200);
		Nixie(4,4);
//		Delay(200);
		Nixie(5,5);
//		Delay(200);
	}
}
```



## 模块化编程

把各个模块代码放在不同的C文件里，在.h文件里提供外部可调用函数的声明，在其他.c文件中想使用其中代码时，只需要#include<.h>

.c文件：函数、变量的定义

.h文件：可被外部调用的函数、变量的声明

注意：1.任何自定义变量、函数调用前必须有定义或声明

2.使用到的自定义函数的.c文件必须添加到工程参与编译

3.使用到的.h文件必须放到编译器可寻找到的位置

### C预编译

```
#include<REGX52.H>
#ifndef __XX_H__
#define __XX_H__
#endif
```

## LCD1602调试工具

通过电位器调节对比度

LCD1602 是一种常见的字符型液晶显示模块，用于显示字符和简单的图形。以下是 LCD1602 各个引脚的作用及其用法的详细解释：

**LCD1602 引脚说明**



1. **VSS (引脚1)**: 接地(GND)。

2. **VDD (引脚2)**: 电源正极(VCC)，通常接5V。

3. **VO (引脚3)**: 对比度调整端，通过一个可变电阻调整液晶显示的对比度。

4. **RS (引脚4)**: 寄存器选择端。

​	•	RS = 0：命令寄存器，用于接收命令。

​	•	RS = 1：数据寄存器，用于接收要显示的数据。

5. **RW (引脚5)**: 读/写选择端。

​	•	RW = 0：写操作。

​	•	RW = 1：读操作。

6. **E (引脚6)**: 使能端。当E从高电平变为低电平时，LCD执行命令。

7. **D0-D7 (引脚7-14)**: 数据总线，用于传输命令或数据。

​	•	D0-D3：低四位数据线（通常在8位模式下使用）。

​	•	D4-D7：高四位数据线（在4位和8位模式下使用）。

8.	**LED+ (引脚15)**: 背光电源正极，通常接5V。
9.	**LED- (引脚16)**: 背光电源负极，接地(GND)。

### 存储器结构

![image-20240827141838248](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240827141838248.png)

![image-20240827142004139](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240827142004139.png)

![image-20240827142734768](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240827142734768.png)

![image-20240827165757068](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240827165757068.png)

流动屏幕：

```C
while(1)
	{
		LCD_WriteCommand(0x18);
		Delay(1000);
	}
```

LCD1602.h

```C
#include <REGX52.H>

sbit LCD_RS=P2^6;
sbit LCD_RW=P2^5;
sbit LCD_E=P2^7;

#define LCD_DataPort P0

void LCD_Delay(void)	//@11.0592MHz
{
	unsigned char data i, j;

	i = 2;
	j = 199;
	do
	{
		while (--j);
	} while (--i);
}

void LCD_WriteCommand(unsigned char Command)
{
	LCD_RS=0;
	LCD_RW=0;
	LCD_DataPort=Command;
	LCD_E=1;
	LCD_Delay();
	LCD_E=0;
	LCD_Delay();
}

void LCD_WriteData(unsigned char Data)
{
	LCD_RS=1;
	LCD_RW=0;
	LCD_DataPort=Data;
	LCD_E=1;
	LCD_Delay();
	LCD_E=0;
	LCD_Delay();
}

void LCD_Init()
{
	LCD_WriteCommand(0x38);//八位数据接口，两行显示，5*7点阵
	LCD_WriteCommand(0x0C);
	LCD_WriteCommand(0x06);
	LCD_WriteCommand(0x01);
}

void  LCD_SetCursor(unsigned char Line,unsigned char Column)
{
	if(Line==1)
	{
		LCD_WriteCommand(0x80|Column-1);
	}
	else
	{
		LCD_WriteCommand(0x80|(Column-1)+0x40);
	}
}
void LCD_ShowChar(unsigned char Line,unsigned char Column,unsigned char Char)
{
	LCD_SetCursor(Line,Column);
	LCD_WriteData(Char);
	
}

void LCD_ShowString(unsigned char Line,unsigned char Column,unsigned char *String)
{
	unsigned char i;
	
	LCD_SetCursor(Line,Column);
	for(i=0;String[i]!='\0';i++)
	{
		LCD_WriteData(String[i]);
	}
	
}
int LCD_Pow(int x,int Y)
{
	unsigned char i;
	int Result=1;
	for(i=0;i<Y;i++)
	{
		Result*=x;
	}
	return Result;
}

void LCD_ShowNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)
{
	unsigned char i;
	LCD_SetCursor(Line,Column);
	for(i=Length;i>0;i--)
	{
		LCD_WriteData(0x30+Number/LCD_Pow(10,i-1)%10);//char类型或者直接+'0'
	}
}

void LCD_ShowSignedNum(unsigned char Line,unsigned char Column,int Number,unsigned char Length)
{
	unsigned char i;
	unsigned int Number1;
	
	LCD_SetCursor(Line,Column);

	if(Number>=0)
	{
		LCD_WriteData('+');
		Number1=Number;
	}
	else
	{
		LCD_WriteData('-');
		Number1=-Number;
	}
	for(i=Length;i>0;i--)
	{
		LCD_WriteData(0x30+Number1/LCD_Pow(10,i-1)%10);//char类型或者直接+'0'
	}
}

void LCD_ShowHexNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)
{
	unsigned char i;
	unsigned char SingleNumber;
	LCD_SetCursor(Line,Column);
	for(i=Length;i>0;i--)
	{
		SingleNumber=Number/LCD_Pow(16,i-1)%16;//char类型或者直接+'0'
		if(SingleNumber<10)
		{
			LCD_WriteData(0x30+SingleNumber);
		}
		else
		{
			LCD_WriteData('A'+SingleNumber-10);

		}
	}
}

void LCD_ShowBinNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)
{
	unsigned char i;
	LCD_SetCursor(Line,Column);
	for(i=Length;i>0;i--)
	{
		LCD_WriteData(0x30+Number/LCD_Pow(2,i-1)%2);//char类型或者直接+'0'
	}
}
	
```



```C
#ifndef __LCD1602_H__
#define __LCD1602_H__

//用户调用函数：
void LCD_Init();
void LCD_ShowChar(unsigned char Line,unsigned char Column,char Char);
void LCD_ShowString(unsigned char Line,unsigned char Column,char *String);
void LCD_ShowNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length);
void LCD_ShowSignedNum(unsigned char Line,unsigned char Column,int Number,unsigned char Length);
void LCD_ShowHexNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length);
void LCD_ShowBinNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length);

#endif

```

```C
#include <REGX52.H>
#include "LCD1602.h"
#include "Delay.h"

int Result=0;
void main()
{
	
	LCD_Init();
//	Result=1+1;
	
//	LCD_ShowChar(1,1,'A');
//	LCD_ShowString(1,3,"Hello");
//	LCD_ShowNum(1,9,123,3);
//	LCD_ShowSignedNum(1,13,-66,2);
//	LCD_ShowHexNum(2,1,0xA8,2);
//	LCD_ShowBinNum(2,4,0xAA,8);//1010 1010//单片机不能发二进制
	while(1)
	{
		Result++;
		Delay(1000);
		LCD_ShowNum(1,1,Result,3);
	}
}
```

## 矩阵键盘

数码管扫描（输出扫描）：显示第一位-第二位-第三位-----，快速循环这个过程，最终实现所有数码管同时显示的效果

矩阵键盘扫描（输入扫描）：读取第一行（列）-读取第二行（列）-----，快速循环这个过程，最终实现所有按键同时检测的效果

共性：节省i/o口

单片机上电的时候，所有IO口默认高电平

IO口：input/output口，可以通过引脚向cpu里输入数据，cpu也可以通过引脚输出电压信号

按下IO口低电平（相当于接地），IO口模式弱上拉。



先按列扫描，后按行扫描

```C
#include "Delay.h"
unsigned char MatrixKey()
{
	unsigned char KeyNumber=0;
	
	P1=0xFF;
	P1_3=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=1;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=5;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=9;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=13;}
	
	P1=0xFF;
	P1_2=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=2;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=6;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=10;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=14;}
	
	P1=0xFF;
	P1_1=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=3;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=7;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=11;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=15;}
	
	P1=0xFF;
	P1_0=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=4;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=8;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=12;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=16;}
}
```



先按行扫描，后按列扫描

```C
#include "Delay.h"
unsigned char MatrixKey()
{
	unsigned char KeyNumber=0;
	
	P1=0xFF;
	P1_7=0;
	if(P1_3==0){Delay(20);while(P1_3==0);Delay(20);KeyNumber=1;}
	if(P1_2==0){Delay(20);while(P1_2==0);Delay(20);KeyNumber=2;}
	if(P1_1==0){Delay(20);while(P1_1==0);Delay(20);KeyNumber=3;}
	if(P1_0==0){Delay(20);while(P1_0==0);Delay(20);KeyNumber=4;}
	
	P1=0xFF;
	P1_6=0;
	if(P1_3==0){Delay(20);while(P1_3==0);Delay(20);KeyNumber=5;}
	if(P1_2==0){Delay(20);while(P1_2==0);Delay(20);KeyNumber=6;}
	if(P1_1==0){Delay(20);while(P1_1==0);Delay(20);KeyNumber=7;}
	if(P1_0==0){Delay(20);while(P1_0==0);Delay(20);KeyNumber=8;}
	P1=0xFF;
	P1_5=0;
	if(P1_3==0){Delay(20);while(P1_3==0);Delay(20);KeyNumber=9;}
	if(P1_2==0){Delay(20);while(P1_2==0);Delay(20);KeyNumber=10;}
	if(P1_1==0){Delay(20);while(P1_1==0);Delay(20);KeyNumber=11;}
	if(P1_0==0){Delay(20);while(P1_0==0);Delay(20);KeyNumber=12;}
	
	P1=0xFF;
	P1_4=0;
	if(P1_3==0){Delay(20);while(P1_3==0);Delay(20);KeyNumber=13;}
	if(P1_2==0){Delay(20);while(P1_2==0);Delay(20);KeyNumber=14;}
	if(P1_1==0){Delay(20);while(P1_1==0);Delay(20);KeyNumber=15;}
	if(P1_0==0){Delay(20);while(P1_0==0);Delay(20);KeyNumber=16;}
}
```

### 矩阵键盘密码锁

```C
#include <REGX52.H>
#include "Delay.h"
#include "LCD1602.h"
#include "MatrixKey.h"

unsigned char KeyNum=0;
unsigned int Password=0,Count=0;//0~65535

void main()
{
	LCD_Init();//初始化
	LCD_ShowString(1,2,"Password");//显示字符
	while(1)
	{
		KeyNum=MatrixKey();
		if(KeyNum)
		{
			if(KeyNum<=10)//如果S1~S10按键按下，输入密码
			{
				if(Count<4)
				{
					Password*=10;//密码左移一位
					Password+=KeyNum%10;//获取一位密码
					Count++;//计次加一
				}
				LCD_ShowNum(2,1,Password,4);
			}
			if(KeyNum==11)//确认键
			{
				if(Password==2345)
				{
					LCD_ShowString(1,14,"OK ");
					Password=0;
					Count=0;
					LCD_ShowNum(2,1,Password,4);
				}
				else
				{
					LCD_ShowString(1,14,"ERR");
					Password=0;
					Count=0;
					LCD_ShowNum(2,1,Password,4);
				}
			}
			if(KeyNum==12)//取消键
			{
				Password=0;
				Count=0;
				LCD_ShowNum(2,1,Password,4);
			}
			
		}
	}
}
//0001
//0010
//0012
//0127
//1278
```

## 定时器

51单片机定时器属于单片机内部资源，其电路的连接和运转均在单片机内部完成

作用：1.计时2.代替长时间Delay

51单片机（8051微控制器）上使用定时器来代替长时间的延时是因为定时器可以更准确地控制时间，并且在延时过程中，微控制器可以处理其他任务，而不是一直停留在延时函数中。这有以下几个好处：

1. **精确计时**：定时器是硬件模块，可以根据预设的计数器值精确地计时，误差较小。而软件延时通常依赖于指令的执行时间，容易受到编译器、处理器频率等因素的影响，误差较大。
2. **释放CPU资源**：使用软件延时，CPU需要一直执行空循环，这不仅浪费了CPU资源，还使得CPU在这段时间内不能执行其他任务。而使用定时器中断，CPU可以在等待定时器溢出期间执行其他任务，提高了系统的整体效率。
3. **灵活性**：定时器可以通过改变初始计数值或预分频系数来实现不同的延时，提供了更大的灵活性。
4. **多任务处理**：在嵌入式系统中，常常需要处理多个任务。使用定时器中断可以在不影响主要程序运行的情况下实现周期性任务。

综上所述，定时器提供了更精确、有效的时间管理方式，并且能够提高系统的效率和多任务处理能力，因此通常被用来代替长时间的软件延时。 

![image-20240817140531966](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240817140531966.png)

STC89C52的T0和T1均有四种工作模式：

模式0:13位定时器/计数器

模式1:16位定时器/计数器

模式2:8位自动重装模式

模式3:两个8位计数器

单片机通过配置寄存器控制内部线路的连接

TCON 、TMOD

在stc软件中，选择**16位不自动重载**，设定1ms计时

![image-20240810150654392](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240810150654392.png)

**删除**	AUXR &= 0x7F;			//定时器时钟12T模式



**定时器初始化之后一直在工作，溢出就中断**

```C
unsigned char KeyNum;

void main()
{
	Timer0_Init();//定时器初始化，溢出后进行中断，中断结束后跳转到while
	
	while(1)
	{
		
	}
}

void Timer0_Routine() interrupt 1
{
	static unsigned int T0count;//静态局部变量，否则每次进入函数就会清零
	TL0 = 0x66;				//为了在指定的1ms时间溢出，每次设置定时初始值//102
	TH0 = 0xFC;				//设置定时初始值//252
	T0count++;
	if(T0count>=1000)
	{
		T0count=0;
		P2_0=~P2_0;//每隔一秒亮灭
	}
}
```

void Timer0_Routine() interrupt 1；中断函数，模式为1

**Timer0.h**

```C
#include <REGX52.H>
void Timer0_Init(void)		//1毫秒@11.0592MHz
{
	TMOD &= 0xF0;			//设置定时器模式
	TMOD |= 0x01;			//设置定时器模式
	TL0 = 0x66;				//设置定时初始值
	TH0 = 0xFC;				//设置定时初始值
	TF0 = 0;				//清除TF0标志
	TR0 = 1;				//定时器0开始计时
	ET0=1;
	EA=1;
	PT0=0;
}
```



### LED流水灯

```C
#include <REGX52.H>
#include "Timer0.h"
#include "Key.h"
#include <INTRINS.H>
//void Timer0_Init()
//{
////	TMOD=0x01;//0000 0001
//	TMOD&=0xF0;//把TMOD低四位清零，高四位保持不变
//	TMOD|=0x01;//按位或，任何数或上0等于任何数前，前7位不变，最后一位为1
//	TF0=0;
//	TR0=1;
//	TH0=64613/256;
//	TL0=64613%256;//101
//	ET0=1;
//	EA=1;
//	PT0=0;
//}

unsigned char KeyNum,LEDMode;

void main()
{
	P2=0xFE;
	Timer0_Init();
	
	while(1)
	{
		KeyNum=Key();
		if(KeyNum)
		{
			if(KeyNum==1) 
			{
				LEDMode++;
				if(LEDMode>=2)
					LEDMode=0;//让LED在0、1之间变化
			}
			
			
		}
	}
}

void Timer0_Routine() interrupt 1
{
	static unsigned int T0count;//静态局部变量，否则每次进入函数就会清零
	TL0 = 0x66;				//设置定时初始值//102
	TH0 = 0xFC;				//设置定时初始值//252
	T0count++;
	if(T0count>=500)
	{
		T0count=0;
		if(LEDMode==0)
			P2=_crol_(P2,1);
		if(LEDMode==1)
			P2=_cror_(P2,1);
	}
}
```



### 位操作

![image-20240814174949561](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240814174949561.png)

### 初始化问题

- **C语言中全局变量的默认初始化**：在C语言中，全局变量如果没有显式初始化，它们会被自动初始化为0。因此，`LEDMode` 在程序开始运行时默认值为0。
- **逻辑上的初始化**：在 `main()` 函数中，`LEDMode` 的值会根据 `KeyNum` 的值进行增加。因此，即使未显式初始化，`LEDMode` 的值仍然能够按照程序逻辑进行正确操作。
- 

### INTRINS.H

unsigned char a=0x80;//1000 0000-0x01//0000 0001

a=\_crol\_(a,1)左移;//0x01-0x02-0x04-0x08

//0000 0001-0000 0010-0000 0100-0000 1000

### LED时钟

```C
#include <REGX52.H>
#include "Delay.h"
#include "LCD1602.h"
#include "Timer0.h"

unsigned char Sec,Min,Hour;

void main()
{
	LCD_Init();
	Timer0_Init();
	
	LCD_ShowString(1,1,"Clock:");
	LCD_ShowString(2,1,"  :  :");

	while(1)
	{
		LCD_ShowNum(2,1,Hour,2);
		LCD_ShowNum(2,4,Min,2);
		LCD_ShowNum(2,7,Sec,2);


	}
}

void Timer0_Routine() interrupt 1
{
	static unsigned int T0count;//静态局部变量，否则每次进入函数就会清零
	TL0 = 0x66;				//设置定时初始值//102
	TH0 = 0xFC;				//设置定时初始值//252
	T0count++;
	if(T0count>=1000)
	{
		T0count=0;
		Sec++;
		if(Sec>=60)
		{
			Sec=0;
			Min++;
			if(Min>=60)
			{
				Min=0;
				Hour++;
				if(Hour>=24)
				{
					Hour=0;
				}
			}
		}
	}
}
```

## 串口通信

51单片机内部自带**UART**（通用异步收发器），可实现单片机串口通信

DB9接口

VGA接口传送视频

简单双向串口通信有两根（单向一根）通信线（发送端：TXD，接收端：RXD）（**交叉连接**）

电平标准不一致时，需要加电平转换芯片

<img src="C:\Users\Anna\Desktop\1.jpg" alt="1" style="zoom: 50%;" />

电平标准：

TTL电平：+5v表示1，0v表示0

RS232电平：-3~-15v表示1，+3~+15表示0（电压变化范围比较大，传输范围十几米）

RS485电平：两线压差+2~+6v表示1，-2~-6v表示0（差分信号：传输距离很远达到1km以上）

————————————————

常见通信接口比较：

一发多收，不能多发一收

|  名称  |       引脚定义       |   通信方式   |    特点    |
| :----: | :------------------: | :----------: | :--------: |
|  UART  |       TXD、RXD       | 全双工、异步 |   点对点   |
|  I^2C  |       SCL、SDA       | 半双工、同步 | 可挂多设备 |
|  SPI   | SCLK、MOSI、MISO、CS | 全双工、同步 | 可挂多设备 |
| 1-Wire |          DQ          | 半双工、异步 | 可挂多设备 |

还有can、usb

![2](C:\Users\Anna\Desktop\51单片机\2.jpg)

STC89C52有1个UART，四种工作模式:

模式0:同步移位寄存器

模式1：8位UART，波特率可变（常用）

模式2：9位UART，波特率固定

模式3：9位UART，波特率可变

————————————————

串口参数：

波特率：串口通信的速率（发送和接受各数据位的间隔时间）

比特率：传送多少位

检验位：用于数据验证（9位后面跟一位）

————

**奇校验**：一个字节8位中“1”的个数，[校验位](https://so.csdn.net/so/search?q=校验位&spm=1001.2101.3001.7020)，添加一位，使9位中“1”的个数为奇数；偶校验同理。

奇校验：就是让原有数据序列中（包括你要加上的一位）1的个数为奇数
10001100（0）你必须添0，这样原来有3个1，已经是奇数了，所以你添上0之后，1的个数还是奇数个。
**偶校验**：就是让原有数据序列中（包括你要加上的一位）1的个数为偶数
10001100（1）你就必须加1了，这样原来有3个1，要想1的个数为偶数，就只能添1了。
————

停止位：用于数据帧

————————————————

![1](C:\Users\Anna\Desktop\51单片机\1.jpg)

SBUF:串口数据缓存寄存器，物理上是两个独立的寄存器，但占用相同的地址。写操作时，写入的是发送寄存器，读操作时，读出的是接收寄存器

串口模式图

![3](C:\Users\Anna\Desktop\51单片机\3.jpg)

SCON寄存器

![image-20240810210122797](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240810210122797.png)



![image-20240811143549937](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240811143549937.png)

在这段代码中，你使用了定时器1来生成波特率，以便通过UART（串行通信）进行数据发送。让我们详细解释一下为什么要用定时器，以及为什么你看到发送的数据不是从 `0x00` 开始。

### 1. 为什么使用定时器？

在8051微控制器中，串口通信的波特率（即数据传输速度）是由定时器1生成的。

- 波特率控制
  - 为了确保数据能够以正确的速度发送和接收，必须设置一个合适的波特率。波特率就是每秒传输的比特数（bps）。在你的代码中，目标波特率是4800bps。

### 2.为什么发送的数据不是从 `0x00` 开始？

**`Sec` 变量的初始值**：

- 在你的代码中，`Sec` 是一个全局变量，默认情况下应该被初始化为0。假设它是正确初始化的，你应该从 `0x00` 开始发送数据。
- 如果你在调试过程中重复执行代码而没有复位设备，`Sec` 可能会保留上次执行时的值，从而导致新一轮发送时从一个非零值开始。

**未执行复位**：

- 如果你在设备上下载代码并运行，未执行复位操作可能导致全局变量的值没有初始化为0。解决办法是手动复位设备或者在 `main()` 函数中显式初始化 `Sec` 变量。

**代码运行逻辑**：

- 如果在其他地方修改过 `Sec` 变量，它可能已经不再是0了。在 `main()` 函数中添加一行 `Sec = 0;` 确保从 `0x00` 开始发送数据。

### 数据显示模式

选择HEX模式

## 中断结构

### 中断查询次序

![image-20240811162034601](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240811162034601.png)

### 一些中断函数

![image-20240811162108805](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240811162108805.png)

### 中断结构

![image-20240811162233856](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240811162233856.png)

## 点阵屏

要把数码管右边的橡皮帽插到左边两根

74HC595(串转并)模块：串行输入并行输出的**移位寄存器**，

<img src="C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240814142908582.png" alt="image-20240814142908582" style="zoom:50%;" />

OE上面加一横线表示低电平有效，OUTPUT Enable

**RCLK，寄存器时钟**

**SRCLR串行清零端，接VCC表示不清空**

QH‘多片级联，扩展IO口

**SER串行数据**

串行，并行

1.并行通讯：同一时刻，可以传输多个bit位的信号，有多少个信号位就需要多少根信号线。

2.串行通讯：同一时刻，只能传输一个bit位的信号，只需要一根信号线。![a3fd88dd32758b3e59faf0087c9be5a](C:\Users\Anna\Documents\WeChat Files\wxid_lqrkt1mxadlp31\FileStorage\Temp\a3fd88dd32758b3e59faf0087c9be5a.jpg)

C51的

sfr：特殊功能寄存器声明

sbit： 特殊位声明

单片机引脚默认高电平，需要先置置零后给高电平。

LED点阵1表示亮

```C
#include <REGX52.H>
#include "Delay.h"

sbit RCK=P3^5;
sbit SCK=P3^6;
sbit SER=P3^4;

#define MATRIX_LED_PORT P0

/**
  * @brief 74HC595写入一个字节
  * @param 要写入的字节
  * @retval 无
  */
void _74HC595_WriteByte(unsigned char Byte)
{
	unsigned char i;
	for(i=0;i<8;i++)
	{
		SER=Byte&(0x80>>i);
		SCK=1;//将数据移进去
		SCK=0;//为下一次移进去做准备
	}
	RCK=1;
	RCK=0;
//	SER=Byte&0x80;
//	SCK=1;//将数据移进去
//	SCK=0;//为下一次移进去做准备
//	SER=Byte&0x40;
//	SCK=1;//将数据移进去
//	SCK=0;//为下一次移进去做准备
//	SER=Byte&0x20;
//	SCK=1;//将数据移进去
//	SCK=0;//为下一次移进去做准备
}

/**
  * @brief LED点阵屏显示一列数据
  * @param Column 列，范围：0~7，0在最左边
  * @param Data 选择列要显示的数据，高位在上，1亮，0灭
  * @retval 无
  */
void MatrixLED_ShowColumn(unsigned char Column,Data)
{
	_74HC595_WriteByte(Data);
	MATRIX_LED_PORT=~(0x80>>Column);//位选
	Delay(1);
	MATRIX_LED_PORT=0xFF;
}
void main()
{
	SCK=0;
	RCK=0;
	while(1)
	{
		MatrixLED_ShowColumn(0,0x30);
		MatrixLED_ShowColumn(1,0x48);
		MatrixLED_ShowColumn(2,0x44);
		MatrixLED_ShowColumn(3,0x22);
		MatrixLED_ShowColumn(4,0x22);
		MatrixLED_ShowColumn(5,0x44);
		MatrixLED_ShowColumn(6,0x48);
		MatrixLED_ShowColumn(7,0x30);
	}
}
```

动画

借助文字取模工具；

```C
#include <REGX52.H>
#include "Delay.h"
#include "MatrixLED.h"

unsigned char code Animation[]={
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xFF,0x10,0x10,0x10,0xFF,0x00,0x0E,0x15,
	0x15,0x15,0x08,0x00,0xFF,0x01,0x02,0x00,
	0xFF,0x01,0x02,0x00,0x0E,0x11,0x11,0x0E,
	0x00,0x7D,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};//放入code不能更改

void main()
{
	unsigned char i,Offset=0,Count=0;
	MatrixLED_Init();
	while(1)
	{
		for(i=0;i<8;i++)
		{
			MatrixLED_ShowColumn(i,Animation[i+Offset]);
		}
		Count++;
		if(Count>10)
		{
			Count=0;
			Offset++;
			if(Offset>40)
			{
				Offset=0;
			}
		}
		
	}
}
```

## DS1302

### 介绍

#### 原理图

<img src="C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240815192859376.png" alt="image-20240815192859376" style="zoom:50%;" />

#### 典型工作电路

<img src="C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240815144250081.png" alt="image-20240815144250081" style="zoom:50%;" />

VCC2 主电源

VCC1 备用电池（开发板上的没有接备用电池）

GND

X1、X2    32.768KHz晶振

CE 芯片使能，当 `CE` 引脚为高电平（1）时，DS1302芯片会进入工作状态，准备接收指令或传输数据；当 `CE` 为低电平（0）时，芯片处于不工作状态，忽略所有输入信号。

IO 数据输入/输出

SCLK 串行时钟，用于同步数据传输



#### 内部结构框图

<img src="C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240815145548993.png" alt="image-20240815145548993" style="zoom:50%;" />

#### 寄存器定义

<img src="C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240815150143806.png" alt="image-20240815150143806" style="zoom:50%;" />

在这个表格中，第一列（READ）和第二列（WRITE）表示读取和写入的地址，也就是当你要访问实时时钟（RTC）芯片中的某个寄存器时，用到的命令地址。

**解释：**

- **READ（读取）**：表示你要从这个地址读取数据。比如，表中的 `81h` 表示你要从 `81h` 这个寄存器读取"秒"的信息。
- **WRITE（写入）**：表示你要向这个地址写入数据。比如，`80h` 表示你要向 `80h` 这个寄存器写入"秒"的信息。

在RTC中，每个时间单位（如秒、分钟、小时等）都有一个相应的寄存器。这些寄存器的作用是存储当前时间的各部分信息。表格的每一行代表一个寄存器（寄存器地址在第一和第二列），并描述了这个寄存器如何分布存储数据。

#### 写保护

控制寄存器的第7位是写保护位。前7位(从0到6位)被迫为0，在读时总是读0。
在对时钟或RAM进行任何写操作之前，第7位必须是0。当值高时，写保护位阻止对任何其他寄存器的写操作也即初始上电状态。因此，WP位应该在试图写入设备之前被清除。
电路上电的初始态WP是1，这时是不能改写上面任何一个时间寄存器的，**只有首先将WP改写为0，才能进行其它寄存器的写操作**

命令字

<img src="C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240815194233988.png" alt="image-20240815194233988" style="zoom:50%;" />

<img src="C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240815194111659.png" alt="image-20240815194111659" style="zoom:50%;" />

**命令字**：在访问这些寄存器时，微控制器会发送相应的命令字。READ列和WRITE列中的数据就是这些命令字。比如，要读取"秒"，你就向RTC发送 `81h` 命令字，然后从这个寄存器读取数据。

#### 时序

<img src="C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240815190033483.png" alt="image-20240815190033483" style="zoom:50%;" />

读只有15个时钟脉冲

在时钟的上升沿IO口的电平数据就会被写入，在时钟的下降沿DS1302会把数据输出（我读数据）

移位寄存器先发最低位

### BCD码

用4位二进制数来表示1位十进制数

0001 0011 表示13

1000 0101 表示85

0001 1010 不合法

BCD、DEC相互转化：

DEC=BCD/16*10+BCD%16

BCD = DEC / 10 * 16 + DEC % 10

### 关于一些问题

#### 为什么初始化时要置0？

1. **`DS1302_CE = 0;`**：在初始化时，将 `CE` 置0是为了确保芯片处于关闭状态，这样可以避免在初始化过程中由于随机信号导致的不期望行为。当 `CE` 为0时，芯片不会响应任何输入信号，因此可以确保初始化的其他操作不被干扰。
2. **`DS1302_SCLK = 0;`**：时钟信号置为0可以确保时钟引脚处于低电平状态，这样可以稳定地开始时钟信号的生成，避免不正确的数据传输。

#### 如果不置0会发生什么？

- **不置 `CE` 为 0**：如果初始化时 `CE` 未被置0，那么芯片可能已经处于激活状态，这意味着它可能会误解在初始化过程中的信号，并将随机的输入视为有效命令，这可能导致意外行为或错误的数据传输。
- **不置 `SCLK` 为 0**：如果时钟引脚在初始化时不是0，则可能会导致芯片在不正确的时间采样或传输数据。这可能导致数据传输过程中出现错误，尤其是在与芯片通信时，时钟信号是非常重要的控制因素。

#### 数字自动加一

DS1302 RTC芯片是一种实时时钟芯片，它会根据内部振荡器的频率自动计时。在这个例子中，`0x81` 寄存器存储的是"秒"的数据，每一秒钟，这个寄存器中的值都会自动增加。

每秒钟，DS1302芯片内部会自动更新秒的值，从 0 增加到 59，然后循环回到 0。

因此，当程序每次执行 `Second = DS1302_ReadByte(0x81)` 时，它获取到的秒数会随着时间推移而不断增加。

```C
#include <REGX52.H>
#include "LCD1602.h"
#include "DS1302.h"


void main()
{
	LCD_Init();
	DS1302_Init();
//	DS1302_WriteByte(0x8E,0x00);//写保护，需要将8E寄存器第7位WP先置零
	LCD_ShowString(1,1,"  -  -  ");
	LCD_ShowString(2,1,"  :  :  ");

	DS1302_SetTime();

	while(1)
	{
		DS1302_ReadTime();
		LCD_ShowNum(1,1,DS1302_Time[0],2);
		LCD_ShowNum(1,4,DS1302_Time[1],2);
		LCD_ShowNum(1,7,DS1302_Time[2],2);
		LCD_ShowNum(2,1,DS1302_Time[3],2);
		LCD_ShowNum(2,4,DS1302_Time[4],2);
		LCD_ShowNum(2,7,DS1302_Time[5],2);
//		Second=DS1302_ReadByte(0x81);
//		Minute=DS1302_ReadByte(0x83);
//		LCD_ShowNum(2,3,Second/16*10+Second%16,2);
//		LCD_ShowNum(2,1,Minute/16*10+Minute%16,2);
		
		
	}
}
```

DS1302模块化 

```C
#include <REGX52.H>

sbit DS1302_SCLK=P3^6;
sbit DS1302_IO=P3^4;
sbit DS1302_CE=P3^5;

#define DS1302_SECOND   0x80
#define DS1302_MINUTE   0x82
#define DS1302_HOUR     0x84
#define DS1302_DATE     0x86
#define DS1302_MONTH    0x88
#define DS1302_DAY   	0x8A
#define DS1302_YEAR     0x8C
#define DS1302_WP       0x8E

char DS1302_Time[]={24,8,15,21,59,55,6};//变成了无符号的


/**
  * @brief DS1302初始化
  * @param 无
  * @retval 无
  */
void DS1302_Init(void)
{
	DS1302_CE=0;
	DS1302_SCLK=0;
}

/**
  * @brief 写入字节 
  * @param Command 命令字，Data 写进去的数字
  * @retval 无
  */
void DS1302_WriteByte(unsigned char Command,Data)
{
	unsigned char i;
	DS1302_CE=1;
	for(i=0;i<8;i++)
	{
		DS1302_IO=Command&(0x01<<i);//命令字
		DS1302_SCLK=1;
		DS1302_SCLK=0;
	}
	for(i=0;i<8;i++)//输入数据，在循环开始，i被清零
	{
		DS1302_IO=Data&(0x01<<i);
		DS1302_SCLK=1;
		DS1302_SCLK=0;
	}
	DS1302_CE=0;
}

/**
  * @brief 读取字节 
  * @param Command 命令字
  * @retval Data 更新后的时间
  */
unsigned char DS1302_ReadByte(unsigned char Command)
{
	unsigned char i,Data=0x00;
	Command|=0x01;//写的地址最后一位置1
	DS1302_CE=1;//芯片使能
	for(i=0;i<8;i++)//输入命令字
	{
		DS1302_IO=Command&(0x01<<i);
		DS1302_SCLK=0;
		DS1302_SCLK=1;//是数据刚好到达上升沿
	}
	for(i=0;i<8;i++)//读取数据
	{
		DS1302_SCLK=1;
		DS1302_SCLK=0;
		if(DS1302_IO){Data|=(0x01<<i);}//IO口是1时，第0位0、1通过怎样的位操作才能得到1呢，明显是或
	}
	DS1302_CE=0;
	DS1302_IO=0;
	return Data;
	
}
/**
  * @brief 将数组存进寄存器，时间是BCD编码
  * @param 无
  * @retval 无
  */
void DS1302_SetTime(void)
{
	DS1302_WriteByte(DS1302_WP,0x00);//关闭写保护
	DS1302_WriteByte(DS1302_YEAR,DS1302_Time[0]/10*16+DS1302_Time[0]%10);
	DS1302_WriteByte(DS1302_MONTH,DS1302_Time[1]/10*16+DS1302_Time[1]%10);
	DS1302_WriteByte(DS1302_DATE,DS1302_Time[2]/10*16+DS1302_Time[2]%10);
	DS1302_WriteByte(DS1302_HOUR,DS1302_Time[3]/10*16+DS1302_Time[3]%10);
	DS1302_WriteByte(DS1302_MINUTE,DS1302_Time[4]/10*16+DS1302_Time[4]%10);
	DS1302_WriteByte(DS1302_SECOND,DS1302_Time[5]/10*16+DS1302_Time[5]%10);
	DS1302_WriteByte(DS1302_DAY,DS1302_Time[6]/10*16+DS1302_Time[6]%10);
	DS1302_WriteByte(DS1302_WP,0x80);//打开写保护

}

/**
  * @brief 将读取出来的时间存入数组，读出来的是BCD码
  * @param 无
  * @retval 无
  */
void DS1302_ReadTime(void)
{
	unsigned char Temp;
	Temp=DS1302_ReadByte(DS1302_YEAR);
	DS1302_Time[0]=Temp/16*10+Temp%16;
	Temp=DS1302_ReadByte(DS1302_MONTH);
	DS1302_Time[1]=Temp/16*10+Temp%16;
	Temp=DS1302_ReadByte(DS1302_DATE);
	DS1302_Time[2]=Temp/16*10+Temp%16;
	Temp=DS1302_ReadByte(DS1302_HOUR);
	DS1302_Time[3]=Temp/16*10+Temp%16;
	Temp=DS1302_ReadByte(DS1302_MINUTE);
	DS1302_Time[4]=Temp/16*10+Temp%16;
	Temp=DS1302_ReadByte(DS1302_SECOND);
	DS1302_Time[5]=Temp/16*10+Temp%16;
	Temp=DS1302_ReadByte(DS1302_DAY);
	DS1302_Time[6]=Temp/16*10+Temp%16;
}
```



!逻辑取反，~按位取反

### 功能完善后的时钟

```C
#include <REGX52.H>
#include "LCD1602.h"
#include "DS1302.h"
#include "Key.h"
#include "Timer0.h"

unsigned char KeyNum,MODE,TimeSetSelect,TimeSetFlashFlag;

void TimeShow(void)//显示时间
{
	DS1302_ReadTime();//读取DS1302内置时间
	LCD_ShowNum(1,1,DS1302_Time[0],2);
	LCD_ShowNum(1,4,DS1302_Time[1],2);
	LCD_ShowNum(1,7,DS1302_Time[2],2);
	LCD_ShowNum(2,1,DS1302_Time[3],2);
	LCD_ShowNum(2,4,DS1302_Time[4],2);
	LCD_ShowNum(2,7,DS1302_Time[5],2);
}

void TimeSet(void)
{
	if(KeyNum==2)
	{
		TimeSetSelect++;
		TimeSetSelect%=6;
	}
	if(KeyNum==3)//对时间进行+操作
	{
		DS1302_Time[TimeSetSelect]++;
		if(DS1302_Time[0]>99){DS1302_Time[0]=0;}
		if(DS1302_Time[1]>12){DS1302_Time[1]=1;}
		if(DS1302_Time[1]==1 || DS1302_Time[1]==3 ||DS1302_Time[1]==5 || DS1302_Time[1]==7 || DS1302_Time[1]==8 || DS1302_Time[1]==10 || DS1302_Time[1]==12 )
		{
			if(DS1302_Time[2]>31){DS1302_Time[2]=1;}
		}
		else if(DS1302_Time[1]==4 ||DS1302_Time[1]==6 || DS1302_Time[1]==9 ||DS1302_Time[1]==11 )
		{
			if(DS1302_Time[2]>30){DS1302_Time[2]=1;}
		}
		else if (DS1302_Time[1]==2)
		{
			if(DS1302_Time[0]%4==0)
			{
				if(DS1302_Time[2]>29){DS1302_Time[2]=1;}
			}
			else
			{
				if(DS1302_Time[2]>28){DS1302_Time[2]=1;}
			}
		}
		if(DS1302_Time[3]>23){DS1302_Time[3]=0;}
		if(DS1302_Time[4]>59){DS1302_Time[4]=0;}
		if(DS1302_Time[5]>59){DS1302_Time[5]=0;}

	}
	if(KeyNum==4)//对时间进行-操作
	{
		DS1302_Time[TimeSetSelect]--;
		if(DS1302_Time[0]<0){DS1302_Time[0]=99;}
		if(DS1302_Time[1]<1){DS1302_Time[1]=12;}
		if(DS1302_Time[1]==1 || DS1302_Time[1]==3 ||DS1302_Time[1]==5 || DS1302_Time[1]==7 || DS1302_Time[1]==8 || DS1302_Time[1]==10 || DS1302_Time[1]==12 )
		{
			if(DS1302_Time[2]<1){DS1302_Time[2]=31;}
			if(DS1302_Time[2]>31){DS1302_Time[2]=1;}

		}
		else if(DS1302_Time[1]==4 ||DS1302_Time[1]==6 || DS1302_Time[1]==9 ||DS1302_Time[1]==11 )
		{
			if(DS1302_Time[2]<1){DS1302_Time[2]=30;}
			if(DS1302_Time[2]>30){DS1302_Time[2]=1;}
		}
		else if (DS1302_Time[1]==2)
		{
			if(DS1302_Time[0]%4==0)
			{
				if(DS1302_Time[2]<1){DS1302_Time[2]=29;}
				if(DS1302_Time[2]>29){DS1302_Time[2]=1;}
			}
			else
			{
				if(DS1302_Time[2]<1){DS1302_Time[2]=28;}
				if(DS1302_Time[2]>28){DS1302_Time[2]=1;}
			}
		}
		if(DS1302_Time[3]<0){DS1302_Time[3]=23;}
		if(DS1302_Time[4]<0){DS1302_Time[4]=59;}
		if(DS1302_Time[5]<0){DS1302_Time[5]=59;}
	}
	
	if(TimeSetSelect==0 && TimeSetFlashFlag==1){LCD_ShowString(1,1,"  ");}//让选择位以一秒为间隔闪烁
	else {LCD_ShowNum(1,1,DS1302_Time[0],2);}
	if(TimeSetSelect==1 && TimeSetFlashFlag==1){LCD_ShowString(1,4,"  ");}
	else {LCD_ShowNum(1,4,DS1302_Time[1],2);}
	if(TimeSetSelect==2 && TimeSetFlashFlag==1){LCD_ShowString(1,7,"  ");}
	else {LCD_ShowNum(1,7,DS1302_Time[2],2);}
	if(TimeSetSelect==3 && TimeSetFlashFlag==1){LCD_ShowString(2,1,"  ");}
	else {LCD_ShowNum(2,1,DS1302_Time[3],2);}
	if(TimeSetSelect==4 && TimeSetFlashFlag==1){LCD_ShowString(2,4,"  ");}
	else {LCD_ShowNum(2,4,DS1302_Time[4],2);}
	if(TimeSetSelect==5 && TimeSetFlashFlag==1){LCD_ShowString(2,7,"  ");}
	else {LCD_ShowNum(2,7,DS1302_Time[5],2);}
	
//	LCD_ShowNum(2,10,TimeSetSelect,1);
//	LCD_ShowNum(2,13,TimeSetFlashFlag,2);

}

void main()
{
	LCD_Init();
	DS1302_Init();
	Timer0_Init();

	LCD_ShowString(1,1,"  -  -  ");
	LCD_ShowString(2,1,"  :  :  ");

	DS1302_SetTime();

	while(1)
	{
		KeyNum=Key();
		if(KeyNum==1)
		{
			if(MODE==0)
			{
				MODE=1;
				TimeSetSelect=0;//推出时间设置，将选择位置零
			}
			else if(MODE==1)
			{
				MODE=0;
				DS1302_SetTime();//把新设置的时间写进去
			}
			
		}
		switch(MODE)//模式选择
		{
			case 0:TimeShow();break;
			case 1:TimeSet();break;
		}
	}
}

void Timer0_Routine() interrupt 1//定时器中断
{
	static unsigned int T0Count;
	TL0 = 0x66;				//设置定时初始值//102
	TH0 = 0xFC;				//设置定时初始值//252
	T0Count++;
	if(T0Count>=500)
	{
		T0Count=0;
		TimeSetFlashFlag=!TimeSetFlashFlag;//逻辑取反
	}
}
```

## 蜂鸣器

蜂鸣器：将电信号转化为声音信号

按驱动方式：

有源蜂鸣器：内部自带振荡源，将正负极接上**直流电压**即可持续发声，频率固定

无源蜂鸣器：内部不带振荡源，需要控制器提供振荡脉冲才可以发声，调整提供震荡脉冲的频率，可发出不同频率声音

<img src="C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240816173315409.png" alt="image-20240816173315409" style="zoom:33%;" />

驱动电路

<img src="C:\Users\Anna\Documents\WeChat Files\wxid_lqrkt1mxadlp31\FileStorage\Temp\ababce9e26499123a10a34610c588f9.jpg" alt="ababce9e26499123a10a34610c588f9" style="zoom:33%;" />

高电平导通的NPN型三极管开关；

低电平导通的PNP型三极管开关

ULN2003



![f3d1c432c542f0ce037591f1c8f95d3](C:\Users\Anna\Documents\WeChat Files\wxid_lqrkt1mxadlp31\FileStorage\Temp\f3d1c432c542f0ce037591f1c8f95d3.jpg)

7个非门，给1，经过非门变成0

### 一些乐理知识

![超清晰钢琴键盘与大谱表、简谱对照_文档之家](https://th.bing.com/th/id/R.4e7c684912507963fff00a425e669582?rik=GXCkgZJNyLRj9g&riu=http%3a%2f%2fwww.doczj.com%2fpic%2fview%3fih%3d1071%26rn%3d1%26doc_id%3d8f9cf9291b37f111f18583d049649b6649d709d0%26o%3dpng_6_0_0_0_0_892_630_892.5_1263%26pn%3d1%26iw%3d1517%26ix%3d0%26sign%3dabf74663d5bd9bb573a88350987f915f%26type%3d1%26iy%3d0%26aimw%3d1517%26app_ver%3d2.9.8.2%26ua%3dbd_800_800_IncredibleS_2.9.8.2_2.3.7%26bid%3d1%26app_ua%3dIncredibleS%26uid%3d%26cuid%3d%26fr%3d3%26Bdi_bear%3dWIFI%26from%3d3_10000%26bduss%3d%26pid%3d1%26screen%3d800_800%26sys_ver%3d2.3.7&ehk=jIbbzeCoQ%2fD6NUiq2xOHi4ltwSPLtHGgPbYPVBWTPUs%3d&risl=&pid=ImgRaw&r=0)

#升高半音，b降低半音

天空之城简谱

![image-20240816212136731](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240816212136731.png)

![C调音符与频率对照表_word文档在线阅读与下载_免费文档](https://img.mianfeiwendang.com/pic/8c7d825b6848e34b74ee232aacdd538aa9e56b06/1-1215-jpg_6-1620-0-0-1620.jpg)

### 低电平导通的原理

在这种电路设计中，通常使用三极管来控制蜂鸣器的开关状态。三极管的特点是，当基极（这里是PWMOUT引脚）为低电平时，其集电极和发射极之间导通。也就是说，**当`PWMOUT`引脚(P25)输出低电平**，三极管导通，这样蜂鸣器的电路就可以闭合，从而使得电流通过蜂鸣器。

然而，**蜂鸣器在接通电源的情况下并不发声**，是因为蜂鸣器的发声原理通常是当其受到**快速的开关信号**时才会发声，类似于通过频率使得震动达到可听范围，因此我们需要控制频率。

### 取反操作

为了使蜂鸣器发声，我们需要在短时间内快速地开关电路。`Buzzer = !Buzzer`表示将`Buzzer`的状态进行取反，即如果当前是高电平就设置为低电平，反之亦然。这样就可以在主循环中不断地开启和关闭蜂鸣器。

### 代码执行过程

在主函数的循环中，使用`while`结构不断更新`Buzzer`的状态输出。当Buzzer状态变化时，蜂鸣器的电路就会相应地开关，产生声响。

### 蜂鸣器的周期

关于频率的计算，使用下面的公式：

- 每次开关的时间为500微秒。
- 一个完整的周期（开+关）是 `500us (开) + 500us (关) = 1000us`。
- 所以频率为：

<img src="C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240817144832873.png" alt="image-20240817144832873" style="zoom:44%;" />

```C
#include <REGX52.H>
#include "Delay.h"
#include "Timer0.h"

sbit Buzzer=P2^5;

#define SPEED  500 
#define P   	0
#define L1 		1
#define L1_  	2
#define L2 		3
#define L2_  	4
#define L3  	5
#define L4  	6
#define L4_  	7
#define L5  	8
#define L5_  	9
#define L6  	10
#define L6_  	11
#define L7  	12
#define M1  	13
#define M1_  	14
#define M2  	15
#define M2_  	16
#define M3  	17
#define M4  	18
#define M4_  	19
#define M5  	20
#define M5_  	21
#define M6  	22
#define M6_  	23
#define M7  	24
#define H1  	25
#define H1_  	26
#define H2  	27
#define H2_  	28
#define H3  	29
#define H4  	30
#define H4_  	31
#define H5  	32
#define H5_  	33
#define H6  	34
#define H6_  	35
#define H7  	36


unsigned char KeyNum;

unsigned int FreqTable[]={0,
	63777,63872,63967,64053,64139,64214,64290,64359,64424,64488,64546,64606,
	64654,64703,64750,64794,64836,64875,64912,64947,64980,65012,65041,65069,
	65094,65119,65142,65165,65186,65205,65223,65241,65258,65273,65288,65302
};
unsigned char code Music[]=
{
	//1
	0,4,
	0,4,
	0,4,
	M6,2,
	M7,2,
	
	H1,6,
	M7,2,
	H1,4,
	H3,4,
	
	M7,12,
	M3,2,
	M3,2,
	
	//2
	M6,6,
	M5,2,
	M6,4,
	H1,4,
	
	M5,12,
	M3,4,
	
	M4,6,
	M3,2,
	M4,4,
	H1,4,
	
	//3
	M3,8,
	0,2,
	H1,2,
	H1,2,
	H1,2,
	
	M7,6,
	M4_,2,
	M4,4,
	M7,4,
		
	0xFF
};
unsigned int FreqSelect,MusicSelect;

void main()
{
	Timer0_Init();
	while(1)
	{
		if(Music[MusicSelect]!=0xFF)
		{
			FreqSelect=Music[MusicSelect];
			MusicSelect++;
			Delay(SPEED/4*Music[MusicSelect]);
			MusicSelect++;
			TR0=0;
			Delay(5);
			TR0=1;
		}
		else
		{
			TR0=0;
			while(1);
		}
	}
}

void Timer0_Routine() interrupt 1
{
	TL0 = FreqTable[FreqSelect]%256;				//设置定时初始值
	TH0 = FreqTable[FreqSelect]/256;				//设置定时初始值
	Buzzer=!Buzzer;
}
```

## AT24C02(I^2C总线)

![image-20240817200355480](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240817200355480.png)

RAM：存储速度最快，掉电丢失  

​	SRAM：最快，在CPU里，容量小，成本高

​	DRAM：利用电容充放电，动态RAM

ROM：永久保存

<img src="C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240818153316234.png" alt="image-20240818153316234" style="zoom:45%;" />

### I^2C总线介绍

两根通信线：SCL、SDA

同步、半双工、带数据应答

设备的SCL和SDA均要配置成**开漏输出模式**（解决多机通信互相干扰的问题）

各线上添加上拉电阻阻值一般在4.7K欧左右

<img src="C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240818160027306.png" alt="image-20240818160027306" style="zoom:50%;" />

<img src="C:\Users\Anna\Documents\WeChat Files\wxid_lqrkt1mxadlp31\FileStorage\Temp\a85a066fc3825580aa4bc5aeb10dd0e.jpg" alt="a85a066fc3825580aa4bc5aeb10dd0e" style="zoom:50%;" />

### 时序结构

![image-20240818162245834](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240818162245834.png)

![image-20240818162437143](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240818162437143.png)

![image-20240818162950471](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240818162950471.png)

![image-20240818163210602](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240818163210602.png)

AT24C02的固定地址为1010，可配置地址本开发板上为000	所以SLAVE ADDRESS+W为0xA0，SLAVE ADDRESS+R为0xA1

### IIC总结

主机发送数据到从机的状态下：主机控制SCL信号线和SDA信号线，从机只是在SCL线为高的时候去被动读取SDA线。
主机读取从机的数据的状态下：主机来发出时钟信号，从机只是保证在时钟信号为高电平的时候的SDA的状态而已。
SDA和SCL已经通过上拉电阻被上拉，master可以控制（拉低或者释放）这两条线，而slaver只能控制SDA线。当master发送数据时，master会适时地将SDA和SCL拉低或释放(拉高)。确切的时序应该是这样的：
当mater要发送一个start时，mater会将SDA拉低，这就可以了，因为此时的SCL一定是High。好了，一个start就这样发出去了。而slaver也会发现这个start信号的发生，slaver便会准备好接收接下来的数据了。紧接着，master要发送一个Byte的数据了，一位一位的发出这8个bits。这时master会先将SCL拉低，然后在SCL为低的状态下将一个bit准备好放到SDA上（比如要发送一个 0，master就会通过拉低SDA来放好这个0），然后master会把SCL拉高（释放），此时slaver会立刻检测到SCL的变化，由此聪明的slaver便知道master已经将要发送的那个bit准备好了，slaver便会在这个SCL的高电平期间尽快（maser不会等你很久的哦）去读取一下SDA，嗯读到了一个0，slaver就把这个0放到自己的移位寄存器中待后续处理。master会在一个设定好的时间后把SCL再次拉低，然后在SCL为低电平期间把下一个bit放到SDA上，然后再把SCL拉高，然后slaver在SCL的高电平期间再去读SDA。。。。。如此反复8次，一个Byte的传输便告结束。当这8个bit发完后，SCL是处于低电平的(被master拉低的)，SDA是出于高电平的(master已经释放了SDA)。
**当一个字节发送完毕后，master会释放SDA（拉高）并拉低SCL**，此时slaver如果打算发出一个ACK的话，它必须在这个SCL被master拉低的短暂时间内去主动将SDA拉低并保持住 (此前我们说过，SDA此时已经被master释放，所以slaver才有机会去拉低这个SDA)。master会在一个确定的时间后再次将SCL拉高，并在拉高的期间去读取SDA线的状态，如果读到低电平，则认为收到了来自slaver的响应（ACK），否则认为slaver没有响应（NACK）刚才发送的那一个Byte。这个过程就是我们说的i2c通讯中的第9个时钟周期。当master读完这个ACK / NACK 后，会再次将SCL拉低，用以通知slaver：第9个时钟周期已经结束，你现在可以释放SDA了。而此时master也可以向SDA上准备下一个Byte的第一个bit。继而重复上述过程。。。。。或者，master也许想在接下来发送一个stop过去，那么master会在这个SCL为低的时间内将SDA拉低，而后再将SCL拉高，在SCL为高的期间再将SDA释放 (拉高) 。这样，一个STOP位就产生了。你会发现此后的SDA和SCL都是高，这就是是所谓的总线空闲了！
一句话：**SCL是单向的，由master控制。而SDA是双向的，master可以控制，slaver也可以控制。**
阅读上述过程时，始终牢记：**SDA上的数据必须在SCL为高电平期间保持稳定，SDA上的数据只能在SCL为低电平期间变化**。（开始信号和结束信号例外）！
另外，需要注意的是，并非每传输8位数据之后，都会有ACK信号，有以下3种例外：
（1）当从机不能响应从机地址时（例如它正忙于其他事而无法相应I2C总线的操作，或者这个地址没有对应的从机），在第9个SCL周期内SDA线没有被拉低，即没有ACK信号。这时，主机发出一个P信号终止传输或者重新发出一个S信号开始新的传输。
（2）如果从机接收器在传输过程中不能接收更多的数据时，它也不会发出ACK信号。这样，主机就可以意识到这点，从而发出一个P信号终止传输或者发出一个S信号开始新的传输。
（3）主机接收器在接收到最后一个字节后，也不会发出ACK信号。于是，从机发送器释放SDA线，以允许主机发出P信号结束传输。

[I2C总结（单主机和多主机）_i2c多主访问研究-CSDN博客](https://blog.csdn.net/qq_26972441/article/details/122881656)

### AT24C02库

```C
#include "REGX52.H"
#include "I2C.h"


#define AT24C02_ADDRESS  0xA0

/**
  * @brief AT24C02写入一个字节
  * @param WordAddress要写入字节的地址
  * @param Data要写入的数据
  * @retval 无
  */
void AT24C02_WriteByte(unsigned char WordAddress,Data)
{
//	unsigned char Ack;暂时不处理应答
	I2C_Start();
	I2C_SendByte(AT24C02_ADDRESS);
	I2C_ReceiveAck();
	I2C_SendByte(WordAddress);
	I2C_ReceiveAck();
	I2C_SendByte(Data);
	I2C_ReceiveAck();
	I2C_Stop();
}


/**
  * @brief  AT24C02读取一个字节
  * @param WordAddress要读取字节的地址
  * @retval Data要读出的数据
  */
unsigned char AT24C02_ReadByte(unsigned char WordAddress)
{
	unsigned char Data;
	I2C_Start();
	I2C_SendByte(AT24C02_ADDRESS);
	I2C_ReceiveAck();
	I2C_SendByte(WordAddress);
	I2C_ReceiveAck();
	
	I2C_Start();
	I2C_SendByte(AT24C02_ADDRESS|0x01);
	I2C_ReceiveAck();
	Data=I2C_ReceiveByte();
	I2C_SendAck(1);
	I2C_Stop();

	return Data;
}
```

### IIC库

```C
#include <REGX52.H>

sbit I2C_SCL=P2^1;
sbit I2C_SDA=P2^0;

/**
  * @brief I2C开始
  * @param 无
  * @retval 无
  */
void I2C_Start(void)
{
	I2C_SDA=1;
	I2C_SCL=1;
	I2C_SDA=0;
	I2C_SCL=0;
}
/**
  * @brief I2C停止
  * @param 无
  * @retval 无
  */

void I2C_Stop(void)
{
	I2C_SDA=0;
	I2C_SCL=1;
	I2C_SDA=1;
}

/**
  * @brief I2C发送一个字节
  * @param Byte
  * @retval 无
  */
void I2C_SendByte(unsigned char Byte)
{
	unsigned char i;
	for(i=0;i<8;i++)
	{
		I2C_SDA=Byte&(0x80>>i);
		I2C_SCL=1;
		I2C_SCL=0;
	}
}

/**
  * @brief I2C接受一个字节
  * @param 无
  * @retval 无
  */
unsigned char I2C_ReceiveByte(void)
{
	unsigned char i,Byte=0x00;
	
	I2C_SDA=1;
	for(i=0;i<8;i++)
	{
		I2C_SCL=1;
		if(I2C_SDA){Byte|=(0x80>>i);}
		I2C_SCL=0;
	}
	return Byte;
}

/**
  * @brief I2C发送应答
  * @param AckBit，0为应答，1为非应答
  * @retval 无
  */
void I2C_SendAck(unsigned char AckBit)
{
	I2C_SDA=AckBit;
	I2C_SCL=1;
	I2C_SCL=0;
}

/**
  * @brief 接收应答
  * @param 无
  * @retval AckBit
  */
unsigned char I2C_ReceiveAck(void)
{
	unsigned char AckBit;
	I2C_SDA=1;
	I2C_SCL=1;
	AckBit=I2C_SDA;
	I2C_SCL=0;
	return AckBit;
}
```

## DS18B20温度传感器

测温范围：-55℃-125℃

通信接口：1-Wire（单总线）

[1-wire单总线浅谈之(一)--协议时序_1-wire 一线式通信协议时序图-CSDN博客](https://blog.csdn.net/solar_Lan/article/details/78093931)

[【常用传感器】DS18B20温度传感器原理详解及例程代码-CSDN博客](https://blog.csdn.net/as480133937/article/details/112604303)

单总线：

```C
#include <REGX52.H>

sbit OneWire_DQ=P3^7;

/**
  * @brief OneWire初始化
  * @param 无
  * @retval AckBit 应答位
  */
unsigned char OneWire_Init(void)
{
	unsigned char data i;
	unsigned char AckBit;
	
	EA=0;
	OneWire_DQ=1;
	OneWire_DQ=0;
	i = 227;while (--i);//Delay 500us
	OneWire_DQ=1;
	i = 29;while (--i);//Delay 70us
	AckBit=OneWire_DQ;//从机拉低总线后会自动释放总线
	i=227;while(--i);//Delay 500us
	EA=1;
	return AckBit;
}

/**
  * @brief OneWire 发送一位
  * @param Bit要发送的数据
  * @retval 无
  */
void OneWire_SendBit(unsigned char Bit)
{

	unsigned char data i;

	EA=0;
	OneWire_DQ=0;
	i = 3;while (--i);//Delay10us
	OneWire_DQ=Bit;
	i = 22;while (--i);//Delay50us
	OneWire_DQ=1;
	EA=1;
}

/**
  * @brief OneWire接受一位
  * @param 无
  * @retval bit接收到的数据
  */
unsigned char OneWire_ReceiveBit(void)
{
	unsigned char Bit;
	unsigned char i;
	
	EA=0;
	OneWire_DQ=0;
	i = 1;while (--i);//Delay5us
	OneWire_DQ=1;
	i = 1;while (--i);//Delay5us
	Bit=OneWire_DQ;
	i = 20;while (--i);//Delay50us
	EA=1;
	return Bit;
}

/**
  * @brief OneWire发送一个字节
  * @param Byte 要发送的字节
  * @retval 无
  */
void OneWire_SendByte(unsigned char Byte)
{
	unsigned char i;
	for(i=0;i<8;i++)
	{
		OneWire_SendBit(Byte&(0x01<<i));
	}
}

/**
  * @brief OneWire接收一个字节
  * @param 无
  * @retval Byte要接收的数据
  */
unsigned char OneWire_ReceiveByte(void)
{
	unsigned char i;
	unsigned char Byte=0x00;
	for(i=0;i<8;i++)
	{
		if(OneWire_ReceiveBit()){Byte|=(0x01<<i);}
	}
	return Byte;
}
```

### DS18B20具体

![image-20240825200408176](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240825200408176.png)

![image-20240825200433755](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240825200433755.png)

异步、半双工单总线只需要一根通信线即可实现数据的双向传输，当采用寄生供电时，还可以省去设备的VDD线路，此时，供电加通信只需要DQ和GND两根线。

![image-20240827170014594](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240827170014594.png)



```C
float DS18B20_ReadT(void)
{
	unsigned char TLSB,TMSB;
	int Temp;
	float T;
	OneWire_Init();
	OneWire_SendByte(DS18B20_SKIP_ROM);
	OneWire_SendByte(DS18B20_READ_SCRATCHPAD);
	TLSB=OneWire_ReceiveByte();
	TMSB=OneWire_ReceiveByte();
	Temp=(TMSB<<8)|TLSB;
	T=Temp/16.0;
	return T;
	
}
```

### 为什么可以左移 8 位？

当我们从 DS18B20 读取温度时，温度数据分为两部分：高字节和低字节。整个温度值是一个 16 位的数值：

- **TMSB** 代表高 8 位
- **TLSB** 代表低 8 位

当我们要将这两个字节合并成一个 16 位的整数时，需要把 **高字节** `TMSB` 左移 8 位，把它的值移动到 16 位整数的高位部分（第 8 到第 15 位），这样就给 **低字节** `TLSB` 腾出了空间来放在低 8 位（第 0 到第 7 位）。

```C
Temp = (TMSB << 8) | TLSB;
```

- `TMSB << 8` 会把高字节左移 8 位，比如如果 `TMSB` 是 `0x01`，则左移后变成 `0x0100`。
- `| TLSB` 是按位或操作，将 `TLSB` 加入到 `Temp` 的低 8 位，比如如果 `TLSB` 是 `0x50`，那么 `Temp` 就变成了 `0x0150`。

![image-20240826231456676](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240826231456676.png)

###  温度转换原理（为什么除以 16）

DS18B20 温度传感器使用 12 位分辨率来表示温度，其中最小的单位是 1/16 度（即 0.0625°C）。但因为 DS18B20 实际上返回的是一个 16 位的有符号整数（高 12 位有效），这个值的单位是 **1/16 度**，需要通过以下步骤转换为实际的摄氏温度：

- 假设 DS18B20 返回的值是 `0x0190`，用 `TMSB` 和 `TLSB` 组合后 `Temp` 等于 `0x0190`，这个 16 位值其实代表 **400** 个 **1/16** 度，即 **400/16 = 25°C**。

## 直流电机

直流电机是一种将电能转换为机械能的装置。一般的直流电机有两个电极，**当电极正接时，电机正转，当电极反接时，电机反转**

直流电机主要由永磁体（定子）、线圈（转子）和换向器组成除直流电机外

常见的电机还有步进电机、舵机、无刷电机、空心杯电机等

<img src="C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240827171818140.png" alt="image-20240827171818140" style="zoom:33%;" />

### PWM

 脉冲宽度调制(PWM)，是英文“Pulse Width Modulation”的缩写，简称脉宽调制，是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术，广泛应用在从测量、通信到功率控制与变换的许多领域中。 

pwm的频率：

是指1秒钟内信号从高电平到低电平再回到高电平的次数(一个周期)；

也就是说一秒钟PWM有多少个周期
单位： Hz
表示方式： 50Hz 100Hz

pwm的周期：

T=1/f
周期=1/频率
50Hz = 20ms 一个周期

如果频率为50Hz ，也就是说一个周期是20ms 那么一秒钟就有 50次PWM周期

**占空比：**
是一个脉冲周期内，高电平的时间与整个周期时间的比例
单位： % (0%-100%)
表示方式：20%

周期： 一个脉冲信号的时间         1s内测周期次数等于频率
脉宽时间： 高电平时间

[PWM原理 PWM频率与占空比详解-CSDN博客](https://blog.csdn.net/as480133937/article/details/103439546)

#### 产生PWM

![image-20240828102641106](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240828102641106.png)

## AD/DA

[全网最全——数字信号和模拟信号的区别_模拟信号和数字信号的区别-CSDN博客](https://blog.csdn.net/weixin_48100941/article/details/126499511)

AD（Analog to Digital）：模拟-数字转换，将模拟信号转换为计算机可操作的数字信号

DA（Digital to Analog）：数字-模拟转换，将计算机输出的数字信号转换为模拟信号

**分辨率**：指AD/DA数字量的精细程度，通常用位数表示。例如，对于5V电源系统来说，8位的AD可将5V等分为256份，即数字量变化最小一个单位时，模拟量变化5V/256=0.01953125V，所以，8位AD的电压分辨率为0.01953125V，AD/DA的位数越高，分辨率就越高

**转换速度**：表示AD/DA的最大采样/建立频率，通常用转换频率或者转换时间来表示，对于采样/输出高速信号，应注意AD/DA的转换速度

**模拟信号**
        模拟信号会随着时间变化的，在一个连续范围内有无限个值。模拟信号使用介质（例如：电线传递电信号）来给定属性传递信号信息。

​    绘制电压与时间的关系图发现模拟信号是平滑切连续的曲线，并且不会产生任何离散变化。

<img src="C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240828103123821.png" alt="image-20240828103123821" style="zoom:50%;" />

**数字信号**
 数字信号是将数据表示成一串**离散**的值。

 采用数字信号，物理量表达的信息有很多种：

可变电流和电压
电磁场的相位或极化
声压
磁存储介质的磁化

数字信号可以用于所有数字电子设备包括计算设备和数据传输设备。

### 运算放大器

<img src="C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240828105115437.png" alt="image-20240828105115437" style="zoom:50%;" />

### XPT2046

[XPT2046的使用_xpt2046 busy要不要连接-CSDN博客](https://blog.csdn.net/qlexcel/article/details/107285016)

          CS：芯片选中信号，当CS_N被拉低时，用来控制转换时序并使能串行输入/输出寄存器以移出或移入数据。当该引脚为高电平时，芯片（ADC）进入掉电模式。
        
        DCLK：外部时钟输入，该时钟用来驱动SARADC的转换进程并驱动数字IO上的串行数据传输。
    
        DIN：芯片的数据串行输入脚，当CS为低电平时，数据在串行时钟DCLK的上升沿被锁存到片上的寄存器。
    
        DOUT：串行数据输出，在串行时钟DCLK的下降沿数据从此引脚上移出，当CS_N引脚为高电平时，该引脚为高阻态。
    
        BUSY：忙输出信号，当芯片接收完命令并开始转换时，该引脚产生一个DCLK周期的高电平。当该引脚由高点平变为低电平的时刻，转换结果的最高位数据呈现在DOUT引脚上，主控可以读取DOUT的值。当CS引脚为高电平时，BUSY引脚为高阻态。


![image-20240828112515637](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240828112515637.png)

![image-20240828124239263](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240828124239263.png)



10011100      0x9C

在这里我们选择**单端**模式

XP表示X Postive

![image-20240828124412759](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240828124412759.png)

```C
#include <REGX52.H>
#include "Delay.h"

sbit XPT2046_CS=P3^5;
sbit XPT2046_DIN=P3^4;
sbit XPT2046_DCLK=P3^6;
sbit XPT2046_DOUT=P3^7;

unsigned int XPT2046_ReadAD(unsigned char Command)
{
	unsigned int ADValue=0;
	unsigned char i;
	
	XPT2046_DCLK=0;
	XPT2046_CS=0;
	for(i=0;i<8;i++)
	{
		XPT2046_DIN=Command&(0x80>>i);
		XPT2046_DCLK=1;
		XPT2046_DCLK=0;
	}
	for(i=0;i<16;i++)
	{
		XPT2046_DCLK=1;
		XPT2046_DCLK=0;
		if(XPT2046_DOUT){ADValue|=(0x8000>>i);}
		Delay(1);
	}
	XPT2046_CS=1;
	if(Command&0x08)
	{
		return ADValue>>8;
	}
	else
	{
		return ADValue>>4;
	}
}

```

DA数模转换

```C
sbit DA=P1^0;

unsigned char Counter,Compare;
unsigned char i;

void main()
{
	Timer0_Init();
	while(1)
	{
		for(i=0;i<100;i++)
		{
			Compare=i;
			Delay(10);
		}
		for(i=100;i>0;i--)
		{
			Compare=i;
			Delay(10);
		}
	}
}


void Timer0_Routine() interrupt 1
{
	TL0 = 0xA4;				//设置定时初始值
	TH0 = 0xFF;				//设置定时初始值
	Counter++;
	Counter%=100;
	if(Counter<Compare)
	{
		DA=0;//LED=0;
	}
	else
	{
		DA=1;//LED=1;
	}
}
```

## 红外遥控

红外遥控是利用红外光进行通信的设备，由红外LED将**调制**后的信号发出，由专用的红外接收头进行解调输出

通信方式：单工，异步红外

LED波长：940nm

通信协议标准：NEC标准

![image-20240828150557707](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240828150557707.png)

调制-接收-解调

### NEC编码

![image-20240828150908246](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20240828150908246.png)
